#!/usr/bin/python3
#+
# This script displays picture files in turn from specified directories,
# and allows the user to hit keystrokes to apply commands to them.
#
# Invoke this script as follows:
#
#     SortPictures [options] item [item ...]
#
# where each "item" is either the name of an image file or of a
# directory containg image files to be shown. Valid options are:
#
#     --act=k:cmd
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, invokes cmd. This option can be
#         specified multiple times with different k values, to define multiple
#         key bindings. When cmd is invoked, occurrences of %s are substituted
#         with the full name of the image file.
#    --move=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         directory dir, which must already exist.
#    --movec=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         directory dir. The directory will be created when the first file is moved
#         into it if it doesn’t already exist.
#    --movesub=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         subdirectory of dir with the same name as its current immediate parent
#         directory. The destination subdirectory of that name will be created
#         if it doesn’t already exist.
#    --random
#         equivalent to --sort=random
#    --scale=scalefactor[,how]
#         specifies a scale factor and method to be applied to each image before display.
#         scalefactor is interpreted as a percentage if it ends with a "%", otherwise
#         as a number. If omitted, the default is 1.0 (100%).
#         how is the scaling method: "nearest", "tiles", "bilinear" or "hyper"
#         (see https://developer.gnome.org/gdk-pixbuf/stable/gdk-pixbuf-Scaling.html#gdk-pixbuf-scale-simple
#         for the details). If omitted, the default is "tiles".
#    --sort=how
#         displays the images in order according to how:
#             none (default) -- no special sorting
#             mod -- sort by last-mod date
#             name -- sort by name
#             random -- display in random order
#    --start=n
#         start the display at picture n in the sequence, instead
#         of picture 1.
#
# Standard keystrokes are:
#    right or down arrow -- go to next picture
#    left or up arrow -- go to previous picture
#    F1 -- write filename path to standard output
#    F11 -- rotate picture anticlockwise
#    F12 -- rotate picture clockwise
#    SPACE -- try to play file as a movie
#    CTRL/Z -- undo last move/movec/movesub action
#
# Copyright 2006-2014 by Lawrence D’Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import os
import random
import subprocess
import getopt
from gi.repository import \
    GObject, \
    Gdk, \
    GdkPixbuf, \
    Gtk

#+
# Useful stuff
#-

def for_each_file(arglist, action, actionarg) :
    """invokes action(FileName, actionarg) for each non-directory item
    found in arglist. If an item is not a directory, passes it directly
    to action; otherwise, passes each file directly contained within it,
    unless the name ends with "...", in which case all file descendants
    of the directory are passed."""

    def for_each(item, recurse) :
        if os.path.isdir(item) :
            for child in os.listdir(item) :
                child = os.path.join(item, child)
                if os.path.isdir(child) :
                    if recurse :
                        for_each(child, True)
                    #end if
                else :
                    action(child, actionarg)
                #end if
            #end for
        else :
            action(item, actionarg)
        #end if
    #end for_each

#begin for_each_file
    for arg in arglist :
        if arg.endswith("...") :
            recurse = True
            arg = arg[0 : -3]
        else :
            recurse = False
        #end if
        for_each(arg, recurse)
    #end for
#end for_each_file

#+
# Keypress actions
#-

def make_run_cmd_action(fmt) :
    """returns a function which substitutes its argument into fmt and
    executes the result as a shell command."""

    def run_cmd_action(filename) :
        cmd = fmt % filename
        print(cmd)
        os.system(cmd)
    #end run_cmd_action

#begin make_run_cmd_action
    return \
        run_cmd_action
#end make_run_cmd_action

def make_move_action(dir, create_if) :
    """returns a function which moves the file named by its argument into dir."""

    def move_action(filename) :
        nonlocal exists
        if not exists :
            os.mkdir(dir)
            print("dir “%s” created" % dir)
            exists = True
        #end if
        dstname = os.path.join(dir, os.path.basename(filename))
        print("move %s => %s" % (filename, dstname))
        os.rename(filename, dstname)
        def undo() :
            print("restore %s => %s" % (dstname, filename))
            os.rename(dstname, filename)
        #end undo
        return \
            undo
    #end move_action

#begin make_move_action
    exists = os.path.isdir(dir)
    if (
            not exists
        and
            (not create_if or os.path.lexists(dir))
    ) :
        raise RuntimeError("“%s” is not a directory" % dir)
    #end if
    return \
        move_action
#end make_move_action

def make_move_sub_action(dir) :
    """returns a function which moves the file named by its argument into
    the corresponding subdirectory of dir."""

    def move_sub_action(filename) :
        parent, child = os.path.split(filename)
        grandparent, parent = os.path.split(parent)
        destdir = os.path.join(dir, parent)
        if not os.path.isdir(destdir) :
            if os.path.lexists(destdir) :
                raise RuntimeError("“%s” is not a directory" % destdir)
            #end if
            os.mkdir(destdir)
        #end if
        dstname = os.path.join(destdir, child)
        print("move %s => %s" % (filename, dstname))
        os.rename(filename, dstname)
        def undo() :
            print("restore %s => %s" % (dstname, filename))
            os.rename(dstname, filename)
        #end undo
        return \
            undo
    #end move_sub_action

#begin make_move_sub_action
    return \
        move_sub_action
#end make_move_sub_action

#+
# GUI callbacks
#-

# globals:
# TheImage -- GDK pixbuf object containing image being displayed
# ImageDisplay -- GTK image object for showing an image
# ImageLabel -- GTK label object for showing image name
#
# Act -- mapping of actions to perform by keystroke
# Files -- list of image files to show
# FileIndex -- index into Files of image being shown

def DestroyWindow(TheWindow) :
    # called when main window’s close box is clicked.
    Gtk.main_quit()
#end DestroyWindow

def LoadImage() :
    # loads and shows the image from the currently selected file.
    global TheImage
    ImageName = Files[FileIndex]
    try :
        TheImage = GdkPixbuf.Pixbuf.new_from_file(ImageName)
    except GObject.GError :
        TheImage = None
    #end try
    if TheImage != None and ScaleFactor != None :
        TheImage = TheImage.scale_simple(int(TheImage.get_width() * ScaleFactor), int(TheImage.get_height() * ScaleFactor), ScaleHow)
    #end if
    ShowImage()
#end LoadImage

def RotateImage(Clockwise) :
    # rotates the displayed image by 90 degrees.
    global TheImage
    if Clockwise :
        Direction = GdkPixbuf.PixbufRotation.CLOCKWISE
    else :
        Direction = GdkPixbuf.PixbufRotation.COUNTERCLOCKWISE
    #end if
    if TheImage != None :
        TheImage = TheImage.rotate_simple(Direction)
    #end if
#end RotateImage

def ShowImage() :
    # displays the currently-loaded image in the main window.
    if TheImage != None :
        ImageWidth = TheImage.get_property("width")
        ImageHeight = TheImage.get_property("height")
        if ImageWidth > MaxImageDisplay.x or ImageHeight > MaxImageDisplay.y :
            ScaleFactor = min \
              (
                MaxImageDisplay.x * 1.0 / ImageWidth,
                MaxImageDisplay.y * 1.0 / ImageHeight
              )
            UseImage = TheImage.scale_simple \
              (
                dest_width = int(round(ScaleFactor * ImageWidth)),
                dest_height = int(round(ScaleFactor * ImageHeight)),
                interp_type = GdkPixbuf.InterpType.BILINEAR
              )
        else :
            ScaleFactor = 1
            UseImage = TheImage
        #end if
        ImageDisplay.set_from_pixbuf(UseImage)
        ScaleDisplay = "%d%%" % round(ScaleFactor * 100)
    else :
        ImageDisplay.set_from_stock \
          (
            Gtk.STOCK_MISSING_IMAGE,
            Gtk.IconSize.LARGE_TOOLBAR
          )
        ScaleDisplay = "?"
    #end if
    ImageLabel.set_text("%u/%u: %s (%s)" % (FileIndex + 1, len(Files), Files[FileIndex], ScaleDisplay))
#end ShowImage

def PlayMovie() :
    # tries to play the file as a movie.
    filename = Files[FileIndex]
    if filename.endswith(".swf") :
        cmd = ("gnash", "-1")
    else :
        cmd = ("ffplay", "-autoexit")
    #end if
    subprocess.check_call \
      (
        args = cmd + (os.path.join(os.getcwd(), filename),),
        stdin = open("/dev/null", "r"), # subprocess.DEVNULL,
      )
#end PlayMovie

def KeyPressEvent(TheWindow, TheEvent) :
    # called in response to a keystroke when the main window has the focus.
    global Files, FileIndex, LastUndo
    # print("Keypress type %d val %d mods %#x" % (TheEvent.type, TheEvent.keyval, TheEvent.state)) # debug
    # print("Event %s" % repr({k : getattr(TheEvent, k) for k in dir(TheEvent) if not k.startswith("_")})) # debug
    Key = TheEvent.keyval
    Masks = Gdk.ModifierType
    Modifiers = \
        (
            TheEvent.state
        &
            # ignore all except basic modifiers. I was getting MOD2_MASK set,
            # which I think corresponds to num lock.
            (
                Masks.CONTROL_MASK
            |
                Masks.HYPER_MASK
            |
                Masks.META_MASK
            |
                Masks.SHIFT_MASK
            |
                Masks.SUPER_MASK
            )
        )
    if Modifiers == 0 :
        if Key == Gdk.KEY_Down or Key == Gdk.KEY_Right :
            if FileIndex + 1 < len(Files) :
                FileIndex += 1
                LoadImage()
            #end if
        elif Key == Gdk.KEY_Up or Key == Gdk.KEY_Left :
            if FileIndex > 0 :
                FileIndex -= 1
                LoadImage()
            #end if
        elif Key == Gdk.KEY_F1 :
            sys.stdout.write(Files[FileIndex] + "\n")
        elif Key == Gdk.KEY_F11 :
            RotateImage(False)
            ShowImage()
        elif Key == Gdk.KEY_F12 :
            RotateImage(True)
            ShowImage()
        elif Key == Gdk.KEY_space :
            PlayMovie()
        elif Key in Act :
            LastUndo = Act[Key](Files[FileIndex])
        #end if
    elif Modifiers == Masks.CONTROL_MASK :
        if Key == Gdk.KEY_z :
            if LastUndo != None :
                Do = LastUndo
                LastUndo = None
                Do()
                LoadImage()
            #end if
        #end if
    #end if
    return True
#end KeyPressEvent

#+
# Mainline
#-

def SetAct(Keyword, Value, MakeAction) :
    if len(Value) > 2 and Value[1] == ":" :
        Act[ord(Value[0])] = MakeAction(Value[2:])
    else :
        raise getopt.error("Invalid %s syntax: %s" % (Keyword, repr(Value)))
    #end if
#end SetAct

def AddFile(Item, Files) :
    # for_each_file action to collect names of all image files.
    Files.append(Item)
#end AddFile

ModDate = {} # cache of mod dates to avoid repeated lookups
def ModDateKey(File) :
    """sort key callback which orders files by their last-mod date."""
    if not File in ModDate :
        ModDate[File] = os.stat(File).st_mtime
    #end if
    return \
        ModDate[File]
#end ModDateKey

def Order(Files) :
    # sorts Files according to the key mapping defined by SortKey.
    Files.sort(key = SortKey)
#end Order

(Opts, Args) = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["act=", "move=", "movec=", "movesub=", "random", "scale=", "sort=", "start="]
  )

Files = []
for_each_file(Args, AddFile, Files)

Act = {}
Sort = None
FileIndex = 0
ScaleFactor = None
for Keyword, Value in Opts :
    if Keyword == "--act" :
        SetAct(Keyword, Value, make_run_cmd_action)
    elif Keyword == "--move" or Keyword == "--movec" :
        SetAct(Keyword, Value, lambda Arg : make_move_action(Arg, Keyword == "--movec"))
    elif Keyword == "--movesub" :
        SetAct(Keyword, Value, make_move_sub_action)
    elif Keyword == "--random" :
        Sort = random.shuffle
    elif Keyword == "--scale" :
        Value = Value.split(",", 1)
        if len(Value) == 2 :
            ScaleHow = \
                {
                    "nearest" : GdkPixbuf.InterpType.NEAREST,
                    "tiles" : GdkPixbuf.InterpType.TILES,
                    "bilinear" : GdkPixbuf.InterpType.BILINEAR,
                    "hyper" : GdkPixbuf.InterpType.HYPER,
                }[Value[1]]
        else :
            ScaleHow = GdkPixbuf.InterpType.TILES # default
        #end if
        Value = Value[0]
        if Value.endswith("%") :
            ScaleFactor = float(Value[:-1]) / 100
        else :
            ScaleFactor = float(Value)
        #end if
    elif Keyword == "--sort" :
        if Value == "random" :
            Sort = random.shuffle
        elif Value == "mod" :
            SortKey = ModDateKey
            Sort = Order
        elif Value == "name" :
            SortKey = lambda Name : os.path.split(Name)[1]
            Sort = Order
        elif Value == "none" :
            Sort = None
        else :
            raise getopt.error("Invalid sort option %s" % Value)
        #end if
    elif Keyword == "--start" :
        FileIndex = int(Value) - 1
    #end if
#end for
if len(Files) == 0 :
    raise getopt.error("Nothing to do")
#end if
if FileIndex < 0 or FileIndex >= len(Files) :
    raise getopt.error("--start index out of range")
#end if
if Sort != None :
    Sort(Files)
#end if

TheImage = None # to begin with
# DefaultScreen = Gdk.display_get_default().get_default_screen()
class MaxImageDisplay :
    """maximum bounds of image display"""
    x = Gdk.Screen.width() - 32
    y = Gdk.Screen.height() - 96
#end MaxImageDisplay
MainWindow = Gtk.Window()
MainWindow.connect("destroy", DestroyWindow)
MainWindow.connect("key_press_event", KeyPressEvent)
MainWindow.set_border_width(10)
MainVBox = Gtk.VBox(False, 8)
ImageDisplay = Gtk.Image()
MainVBox.pack_start(ImageDisplay, False, False, 0)
ImageLabel = Gtk.Label()
MainVBox.pack_start(ImageLabel, False, False, 0)
MainWindow.add(MainVBox)
MainWindow.show_all()
MainWindow.show()
LoadImage()
Gtk.main()
