#!/usr/bin/python3
#+
# This script displays picture files in turn from specified directories,
# and allows the user to hit keystrokes to apply commands to them.
#
# Invoke this script as follows:
#
#     SortPictures [options] item [item ...]
#
# where each "item" is either the name of an image file or of a
# directory containg image files to be shown. Valid options are:
#
#     --act=k:cmd
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, invokes cmd. This option can be
#         specified multiple times with different k values, to define multiple
#         key bindings. When cmd is invoked, occurrences of %s are substituted
#         with the full name of the image file.
#    --move=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         directory dir, which must already exist.
#    --movec=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         directory dir. The directory will be created when the first file is moved
#         into it if it doesn’t already exist.
#    --movesub=k:dir
#         defines a key binding, where k is a single ASCII character
#         which, when typed by the user, will move the current file into the
#         subdirectory of dir with the same name as its current immediate parent
#         directory. The destination subdirectory of that name will be created
#         if it doesn’t already exist.
#    --random
#         equivalent to --sort=random
#    --scale=scalefactor[,how]
#         specifies a scale factor and method to be applied to each image before display.
#         scalefactor is interpreted as a percentage if it ends with a "%", otherwise
#         as a number. If omitted, the default is 1.0 (100%).
#         how is the scaling method: "nearest", "tiles", "bilinear" or "hyper"
#         (see https://developer.gnome.org/gdk-pixbuf/stable/gdk-pixbuf-Scaling.html#gdk-pixbuf-scale-simple
#         for the details). If omitted, the default is "tiles".
#    --sort=how
#         displays the images in order according to how:
#             none (default) -- no special sorting
#             mod -- sort by last-mod date
#             name -- sort by name
#             random -- display in random order
#    --start=n
#         start the display at picture n in the sequence, instead
#         of picture 1.
#    --trash
#         enable the use of the DEL key to move the file into the Trash folder.
#
# Standard keystrokes are:
#    right or down arrow -- go to next picture
#    left or up arrow -- go to previous picture
#    F1 -- write filename path to standard output
#    F11 -- rotate picture anticlockwise
#    F12 -- rotate picture clockwise
#    SPACE -- try to play file as a movie
#    CTRL/Z -- undo last move/movec/movesub action
#
# Copyright 2006-2014 by Lawrence D’Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

import sys
import os
import random
import subprocess
import getopt
from gi.repository import \
    GObject, \
    Gdk, \
    GdkPixbuf, \
    Gtk

#+
# Useful stuff
#-

def for_each_file(arglist, action, actionarg) :
    """invokes action(filename, actionarg) for each non-directory item
    found in arglist. If an item is not a directory, passes it directly
    to action; otherwise, passes each file directly contained within it,
    unless the name ends with "...", in which case all file descendants
    of the directory are passed."""

    def for_each(item, recurse) :
        if os.path.isdir(item) :
            for child in os.listdir(item) :
                child = os.path.join(item, child)
                if os.path.isdir(child) :
                    if recurse :
                        for_each(child, True)
                    #end if
                else :
                    action(child, actionarg)
                #end if
            #end for
        else :
            action(item, actionarg)
        #end if
    #end for_each

#begin for_each_file
    for arg in arglist :
        if arg.endswith("...") :
            recurse = True
            arg = arg[0 : -3]
        else :
            recurse = False
        #end if
        for_each(arg, recurse)
    #end for
#end for_each_file

#+
# Keypress actions
#
# The routine that actually performs the action on the file can
# return another routine which will undo the action.
#-

def make_run_cmd_action(fmt) :
    """returns a function which substitutes its argument into fmt and
    executes the result as a shell command."""

    def run_cmd_action(filename) :
        cmd = fmt % filename
        print(cmd)
        os.system(cmd)
    #end run_cmd_action

#begin make_run_cmd_action
    return \
        run_cmd_action
#end make_run_cmd_action

def make_move_action(dir, create_if) :
    """returns a function which moves the file named by its argument into dir."""

    def move_action(filename) :
        nonlocal exists
        if not exists :
            os.mkdir(dir)
            print("dir “%s” created" % dir)
            exists = True
        #end if
        dstname = os.path.join(dir, os.path.basename(filename))
        print("move %s => %s" % (filename, dstname))
        os.rename(filename, dstname)
        def undo() :
            print("restore %s => %s" % (dstname, filename))
            os.rename(dstname, filename)
        #end undo
        return \
            undo
    #end move_action

#begin make_move_action
    exists = os.path.isdir(dir)
    if (
            not exists
        and
            (not create_if or os.path.lexists(dir))
    ) :
        raise RuntimeError("“%s” is not a directory" % dir)
    #end if
    return \
        move_action
#end make_move_action

def make_move_sub_action(dir) :
    """returns a function which moves the file named by its argument into
    the corresponding subdirectory of dir."""

    def move_sub_action(filename) :
        parent, child = os.path.split(filename)
        grandparent, parent = os.path.split(parent)
        destdir = os.path.join(dir, parent)
        if not os.path.isdir(destdir) :
            if os.path.lexists(destdir) :
                raise RuntimeError("“%s” is not a directory" % destdir)
            #end if
            os.mkdir(destdir)
        #end if
        dstname = os.path.join(destdir, child)
        print("move %s => %s" % (filename, dstname))
        os.rename(filename, dstname)
        def undo() :
            print("restore %s => %s" % (dstname, filename))
            os.rename(dstname, filename)
        #end undo
        return \
            undo
    #end move_sub_action

#begin make_move_sub_action
    return \
        move_sub_action
#end make_move_sub_action

def move_trash_action(filename) :
    """moves the filename to the trash."""
    homedir = os.path.abspath(os.getenv("HOME", "/")) + "/"
    fullpath = os.path.abspath(filename)
    trashdir = os.path.join(homedir, "Trash")
    if fullpath.startswith(homedir) :
        trashpath = trashdir + "/" + fullpath[len(homedir):]
    else :
        trashpath = trashdir + fullpath
    #end if
    print("trash %s => %s" % (fullpath, trashpath))
    os.makedirs(os.path.split(trashpath)[0], exist_ok = True)
    os.rename(fullpath, trashpath)
    def undo() :
        print("restore %s => %s" % (trashpath, fullpath))
        os.rename(trashpath, fullpath)
    #end undo
    return \
        undo
#end move_trash_action

#+
# GUI callbacks
#-

# globals:
# the_image -- GDK pixbuf object containing image being displayed
# image_display -- GTK image object for showing an image
# image_label -- GTK label object for showing image name
#
# actions -- mapping of actions to perform by keystroke
# files -- list of image files to show
# file_index -- index into files of image being shown

def destroy_window(the_window) :
    # called when main window’s close box is clicked.
    Gtk.main_quit()
#end destroy_window

def load_image() :
    # loads and shows the image from the currently selected file.
    global the_image
    imagename = files[file_index]
    try :
        the_image = GdkPixbuf.Pixbuf.new_from_file(imagename)
    except GObject.GError :
        the_image = None
    #end try
    if the_image != None and scale_factor != None :
        the_image = the_image.scale_simple(int(the_image.get_width() * scale_factor), int(the_image.get_height() * scale_factor), scale_how)
    #end if
    show_image()
#end load_image

def rotate_image(clockwise) :
    # rotates the displayed image by 90 degrees.
    global the_image
    if clockwise :
        direction = GdkPixbuf.PixbufRotation.CLOCKWISE
    else :
        direction = GdkPixbuf.PixbufRotation.COUNTERCLOCKWISE
    #end if
    if the_image != None :
        the_image = the_image.rotate_simple(direction)
    #end if
#end rotate_image

def show_image() :
    # displays the currently-loaded image in the main window.
    if the_image != None :
        image_width = the_image.get_property("width")
        image_height = the_image.get_property("height")
        if image_width > MaxImageDisplay.x or image_height > MaxImageDisplay.y :
            scale_factor = min \
              (
                MaxImageDisplay.x * 1.0 / image_width,
                MaxImageDisplay.y * 1.0 / image_height
              )
            use_image = the_image.scale_simple \
              (
                dest_width = int(round(scale_factor * image_width)),
                dest_height = int(round(scale_factor * image_height)),
                interp_type = GdkPixbuf.InterpType.BILINEAR
              )
        else :
            scale_factor = 1
            use_image = the_image
        #end if
        image_display.set_from_pixbuf(use_image)
        scale_display = "%d%%" % round(scale_factor * 100)
    else :
        image_display.set_from_stock \
          (
            Gtk.STOCK_MISSING_IMAGE,
            Gtk.IconSize.LARGE_TOOLBAR
          )
        scale_display = "?"
    #end if
    image_label.set_text("%u/%u: %s (%s)" % (file_index + 1, len(files), files[file_index], scale_display))
#end show_image

def play_movie() :
    # tries to play the file as a movie.
    filename = files[file_index]
    if filename.endswith(".swf") :
        cmd = ("gnash", "-1")
    else :
        cmd = ("ffplay", "-autoexit")
    #end if
    subprocess.check_call \
      (
        args = cmd + (os.path.join(os.getcwd(), filename),),
        stdin = open("/dev/null", "r"), # subprocess.DEVNULL,
      )
#end play_movie

def key_press_event(the_window, the_event) :
    # called in response to a keystroke when the main window has the focus.
    global files, file_index, last_undo
    # print("Keypress type %d val %d mods %#x" % (the_event.type, the_event.keyval, the_event.state)) # debug
    # print("Event %s" % repr({k : getattr(the_event, k) for k in dir(the_event) if not k.startswith("_")})) # debug
    key = the_event.keyval
    masks = Gdk.ModifierType
    modifiers = \
        (
            the_event.state
        &
            # ignore all except basic modifiers. I was getting MOD2_MASK set,
            # which I think corresponds to num lock.
            (
                masks.CONTROL_MASK
            |
                masks.HYPER_MASK
            |
                masks.META_MASK
            |
                masks.SHIFT_MASK
            |
                masks.SUPER_MASK
            )
        )
    if modifiers == 0 :
        if key == Gdk.KEY_Down or key == Gdk.KEY_Right :
            if file_index + 1 < len(files) :
                file_index += 1
                load_image()
            #end if
        elif key == Gdk.KEY_Up or key == Gdk.KEY_Left :
            if file_index > 0 :
                file_index -= 1
                load_image()
            #end if
        elif key == Gdk.KEY_F1 :
            sys.stdout.write(files[file_index] + "\n")
        elif key == Gdk.KEY_F11 :
            rotate_image(False)
            show_image()
        elif key == Gdk.KEY_F12 :
            rotate_image(True)
            show_image()
        elif key == Gdk.KEY_Delete :
            if enable_trash :
                last_undo = move_trash_action(files[file_index])
            #end if
        elif key == Gdk.KEY_space :
            play_movie()
        elif key in actions :
            last_undo = actions[key](files[file_index])
        #end if
    elif modifiers == masks.CONTROL_MASK :
        if key == Gdk.KEY_z :
            if last_undo != None :
                do = last_undo
                last_undo = None
                do()
                load_image()
            #end if
        #end if
    #end if
    return True
#end key_press_event

#+
# Mainline
#-

def set_act(keyword, value, make_action) :
    if len(value) > 2 and value[1] == ":" :
        actions[ord(value[0])] = make_action(value[2:])
    else :
        raise getopt.error("Invalid %s syntax: %s" % (keyword, repr(value)))
    #end if
#end set_act

def add_file(item, files) :
    # for_each_file action to collect names of all image files.
    files.append(item)
#end add_file

mod_date = {} # cache of mod dates to avoid repeated lookups
def mod_date_key(filename) :
    """sort key callback which orders files by their last-mod date."""
    if not filename in mod_date :
        mod_date[filename] = os.stat(filename).st_mtime
    #end if
    return \
        mod_date[filename]
#end mod_date_key

def order(files) :
    # sorts files according to the key mapping defined by sort_key.
    files.sort(key = sort_key)
#end order

(opts, args) = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["act=", "move=", "movec=", "movesub=", "random", "scale=", "sort=", "start=", "trash"]
  )

files = []
for_each_file(args, add_file, files)

actions = {}
do_sort = None
enable_trash = False
file_index = 0
scale_factor = None
for keyword, value in opts :
    if keyword == "--act" :
        set_act(keyword, value, make_run_cmd_action)
    elif keyword == "--move" or keyword == "--movec" :
        set_act(keyword, value, lambda Arg : make_move_action(Arg, keyword == "--movec"))
    elif keyword == "--movesub" :
        set_act(keyword, value, make_move_sub_action)
    elif keyword == "--random" :
        do_sort = random.shuffle
    elif keyword == "--scale" :
        value = value.split(",", 1)
        if len(value) == 2 :
            scale_how = \
                {
                    "nearest" : GdkPixbuf.InterpType.NEAREST,
                    "tiles" : GdkPixbuf.InterpType.TILES,
                    "bilinear" : GdkPixbuf.InterpType.BILINEAR,
                    "hyper" : GdkPixbuf.InterpType.HYPER,
                }[value[1]]
        else :
            scale_how = GdkPixbuf.InterpType.TILES # default
        #end if
        value = value[0]
        if value.endswith("%") :
            scale_factor = float(value[:-1]) / 100
        else :
            scale_factor = float(value)
        #end if
    elif keyword == "--sort" :
        if value == "random" :
            do_sort = random.shuffle
        elif value == "mod" :
            sort_key = mod_date_key
            do_sort = order
        elif value == "name" :
            sort_key = lambda name : os.path.split(name)[1]
            do_sort = order
        elif value == "none" :
            do_sort = None
        else :
            raise getopt.error("Invalid sort option %s" % value)
        #end if
    elif keyword == "--start" :
        file_index = int(value) - 1
    elif keyword == "--trash" :
        enable_trash = True
    #end if
#end for
if len(files) == 0 :
    raise getopt.error("Nothing to do")
#end if
if file_index < 0 or file_index >= len(files) :
    raise getopt.error("--start index out of range")
#end if
if do_sort != None :
    do_sort(files)
#end if

the_image = None # to begin with
# default_screen = Gdk.display_get_default().get_default_screen()
class MaxImageDisplay :
    """maximum bounds of image display"""
    x = Gdk.Screen.width() - 32
    y = Gdk.Screen.height() - 96
#end MaxImageDisplay
main_window = Gtk.Window()
main_window.connect("destroy", destroy_window)
main_window.connect("key_press_event", key_press_event)
main_window.set_border_width(10)
main_vbox = Gtk.VBox(False, 8)
image_display = Gtk.Image()
main_vbox.pack_start(image_display, False, False, 0)
image_label = Gtk.Label()
main_vbox.pack_start(image_label, False, False, 0)
main_window.add(main_vbox)
main_window.show_all()
main_window.show()
load_image()
Gtk.main()
